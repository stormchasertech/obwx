#errorCatcher Echo

const appData = {
    lastWindRotation: undefined,
    windSpdDial: {
        defaultMax: 20,
        currentMax: undefined
    },
    colorDict: [
        { 'tempF': 120, 'color': 'rgb(160,0,128)' },
        { 'tempF': 115, 'color': 'rgb(176,0,112)' },
        { 'tempF': 110, 'color': 'rgb(192,0,96)' },
        { 'tempF': 105, 'color': 'rgb(208,0,80)' },
        { 'tempF': 100, 'color': 'rgb(224,0,60)' },
        { 'tempF': 95, 'color': 'rgb(225,0,0)' },
        { 'tempF': 90, 'color': 'rgb(225,86,25)' },
        { 'tempF': 85, 'color': 'rgb(240,128,50)' },
        { 'tempF': 80, 'color': 'rgb(240,160,70)' },
        { 'tempF': 75, 'color': 'rgb(228,196,85)' },
        { 'tempF': 70, 'color': 'rgb(240,228,85)' },
        { 'tempF': 65, 'color': 'rgb(212,240,60)' },
        { 'tempF': 60, 'color': 'rgb(160,240,0)' },
        { 'tempF': 55, 'color': 'rgb(0,240,0)' },
        { 'tempF': 50, 'color': 'rgb(0,240,144)' },
        { 'tempF': 45, 'color': 'rgb(0,224,176)' },
        { 'tempF': 40, 'color': 'rgb(0,208,208)' },
        { 'tempF': 35, 'color': 'rgb(32,196,240)' },
        { 'tempF': 30, 'color': 'rgb(64,160,240)' },
        { 'tempF': 25, 'color': 'rgb(64,128,240)' },
        { 'tempF': 20, 'color': 'rgb(64,64,255)' },
        { 'tempF': 15, 'color': 'rgb(128,0,255)' },
        { 'tempF': 10, 'color': 'rgb(144,32,224)' },
        { 'tempF': 5, 'color': 'rgb(160,32,208)' },
        { 'tempF': 0, 'color': 'rgb(176,32,192)' },
        { 'tempF': -5, 'color': 'rgb(160,64,176)' },
        { 'tempF': -10, 'color': 'rgb(144,96,160)' },
        { 'tempF': -15, 'color': 'rgb(128,112,14)' },
        { 'tempF': -20, 'color': 'rgb(144,128,160)' },
        { 'tempF': -25, 'color': 'rgb(160,144,176)' },
        { 'tempF': -30, 'color': 'rgb(176,160,192)' },
        { 'tempF': -35, 'color': 'rgb(200,181,200)' },
        { 'tempF': -40, 'color': 'rgb(219,210,220)' },
        { 'tempF': -45, 'color': 'rgb(220,220,225)' },
        { 'tempF': -50, 'color': 'rgb(240,240,240)' }
    ]
}

function colorizeTemp ( temperature ) {
    return appData.colorDict.find( (dictObj) => dictObj.tempF <= temperature ).color;
}

function localizeDate ( date ) { 
    const dateObj = new Date(date);
    const settings = { 
        dateStyle: 'full',
        timeStyle: 'long', 
        timeZone: '$Extras.timezone',
        hour12: true
    }   
    const dateArr = new Intl.DateTimeFormat(undefined,settings).format(dateObj).replace(/,/g,'').split(' ');
    return {
        A: dateArr[0],
        a: new Intl.DateTimeFormat(undefined,{weekday:"short"}).format(dateObj),
        M: dateArr[1],
        m: new Intl.DateTimeFormat(undefined,{month:"short"}).format(dateObj),
        d: dateArr[2],
        Y: dateArr[3],
        T: dateArr[5],
        t: dateArr[5].substr(0,dateArr[5].length-3),
        p: dateArr[6],
        tz: dateArr[7],
    };  
};

function rotateWindDir ( direction, lastRotation ) {
    if ( direction != 'N/A' ) { 
        let finalRotation = lastRotation || 0;
        let currentRotation = finalRotation % 360;

        if ( currentRotation < 0 ) { currentRotation += 360; }
        if ( currentRotation <  180 && direction > (currentRotation + 180) ) { finalRotation -= 360; }
        if ( currentRotation >= 180 && direction <= (currentRotation - 180) ) { finalRotation += 360; }

        finalRotation += ( direction - currentRotation );
        appData.lastWindRotation = finalRotation;
        return finalRotation;

    } else { 
        console.log(`Check rotateWindDir function: \${direction}`); 
        return;
    }
}

function windSpdToAngle ( windSpeed, scaleMax ) {
    if ( scaleMax != undefined ){
        const angle = (windSpeed / scaleMax * 180) - 90;
        // Prevent overshoot by returning 90 if over 90 deg
        return angle > 90 ? 90 : angle;
    } else {
        return -90;
    }
}

/////////////////////////
// Connect to mqtt server
/////////////////////////
function mqttconnect() {
    const client = new Paho.Client('$Extras.websocket_host', $Extras.websocket_port, mqttclient);
    const mqtt_options = { 
        useSSL: true,
        reconnect: true,
        onSuccess: onConnect,
        onFailure: onFailure
    }   
    function onConnect () {
        client.subscribe( '$Extras.websocket_topic' );
        console.warn('Successfully connected to mqtt server');
    }   
    function onFailure () {
        console.warn('Connection to mqtt server FAILED');
    }   
    function onConnectionLost ( responseObject ) { 
        if ( responseObject.errorCode !== 0 ) { 
            console.warn(`MQTT disconnected: \${responseObject.errorMessage}` );
        }
    }   
    function onMessageArrived ( message ) { 
        const loopData = jQuery.parseJSON(message.payloadString);  
        processLoop(loopData);
        // interval_minute signals that archive and forecast data has been updated
        if ( loopData.hasOwnProperty('interval_minute') ) {
            setTimeout( updateArcCast, 15000 );
        }
    }
    client.connect( mqtt_options );
    client.onMessageArrived = onMessageArrived;
    client.onConnectionLost = onConnectionLost;
}

function updateArcCast() {
    jQuery.getJSON( 'archive.json', processArchive );
    jQuery.getJSON( 'forecast.json', processForecast );
}

//////////////////////////
// Process and update with new data 
//////////////////////////
function processLoop ( data ) {

    if ( data.hasOwnProperty( 'altimeter_inHg' ) ) {
        jQuery('.altimeter').html( `Altimeter: \${data.altimeter_inHg}` );
    }
    if ( data.hasOwnProperty( 'appTemp_F' ) ) {
        jQuery('.feels-like').html( `Feels Like: \${parseFloat(data.appTemp_F).toFixed(1)}&deg;` );
    }
    if ( data.hasOwnProperty('barometer_inHg') ) {
        jQuery('.barometer').html(`Barometer: \${parseFloat( data.barometer_inHg ).toFixed(2)}` );
    }
    if ( data.hasOwnProperty( 'dateTime' ) ) {
        const td = localizeDate(parseFloat(data.dateTime)*1000);
        jQuery('.updated-date').html( `\${td.A}, \${td.m} \${td.d}` );
        jQuery('.updated-time').html( `\${td.T} \${td.p} \${td.tz}` );
    }
    if ( data.hasOwnProperty( 'dayRain_in' ) ) {
        const dayRain = parseFloat(data.dayRain_in).toFixed(2);
        // Move rain level in the gauge (percent of one inch)
        const rainLevel = (( 1 - dayRain ) * 112 ) + 1;
        rainLevel < 1 ? rainLevel = 1 : rainLevel;
        jQuery('.raingauge-rain').css( `top`,`\${rainLevel}px` );
        jQuery('.raingauge-dayRain').html( `\${dayRain}"` );
    }
    if ( data.hasOwnProperty( 'dewpoint_F' ) ) {
        jQuery('.dewpoint').html(`Dewpoint: \${parseFloat( data.dewpoint_F ).toFixed(1)}&deg;` );
    }
    if ( data.hasOwnProperty( 'extraHumid1' ) ) {
        jQuery('.extraHumid1').html(`Extra Humid1: \${parseFloat( data.extraHumid1 ).toFixed(0)}` );
    }
    if ( data.hasOwnProperty( 'extraHumid2' ) ) {
        jQuery('.extraHumid2').html(`Extra Humid2: \${parseFloat( data.extraHumid2 ).toFixed(0)}` );
    }
    if ( data.hasOwnProperty( 'extraTemp1_F' ) ) {
        jQuery('.extraTemp1').html(`Extra Temp1: \${parseFloat( data.extraTemp1_F ).toFixed(1)}` );
    }
    if ( data.hasOwnProperty( 'extraTemp2_F' ) ) {
        jQuery('.extraTemp2').html(`Extra Temp2: \${parseFloat( data.extraTemp2_F ).toFixed(1)}` );
    }
    if ( data.hasOwnProperty( 'inDewpoint_F' ) ) {
        jQuery('.inDewpoint').html(`inDewpoint: \${parseFloat( data.inDewpoint_F ).toFixed(1)}` );
    }
    if ( data.hasOwnProperty( 'inHumidity' ) ) {
        jQuery('.inHumidity').html(`Inside Humidity: \${parseFloat( data.inHumidity ).toFixed(0)}` );
    }
    if ( data.hasOwnProperty( 'inTemp_F' ) ) {
        jQuery('.inTemp').html(`Inside Temp: \${parseFloat( data.inTemp_F ).toFixed(1)}` );
    }
    if ( data.hasOwnProperty( 'outHumidity' ) ) {
        jQuery('.outHumidity').html(`Humidity: \${parseFloat( data.outHumidity ).toFixed(1)} &percnt;`);
    }
    if ( data.hasOwnProperty( 'outTemp_F' ) ) {
        jQuery('.outTemp').html( `\${parseFloat( data.outTemp_F ).toFixed(1)}<sup>&deg;</sup>` );
        jQuery('.outTemp').css( 'color', colorizeTemp( data.outTemp_F) );
    }
    if ( data.hasOwnProperty( 'rainRate_inch_per_hour') ) {
        jQuery('.rainrate').html( `\${parseFloat(data.rainRate_inch_per_hour).toFixed(2)}"/hr`);
    }
    if ( data.hasOwnProperty( 'windDir' )) {
        jQuery('.arrow').css( 'transform', `rotate(\${rotateWindDir( data.windDir, appData.lastWindRotation )}deg` );
        jQuery('.wind-direction-deg').html( parseFloat(data.windDir).toFixed(0) );
    }
    if ( data.hasOwnProperty('windSpeed_mph') ) {
        jQuery('.wind-speed-mph').html( parseFloat(data.windSpeed_mph).toFixed(0) );
        jQuery('.windometer-arrow').css('transform', `rotate(\${windSpdToAngle( data.windSpeed_mph, appData.windSpdDial.currentMax )}deg)`);
    }
    if ( data.hasOwnProperty( 'UV' ) ) {
        jQuery('.uv').html( `UV Index: \${parseInt(data.UV)}` );
    }
    // Other rain loop data items = hourRain_in , rain24_in, rain_in, rain_total
}

function processArchive( data ) {

    // Current and recent wind speed data and widgit settings
    const lastHourHigh = parseFloat(data.today.wind.windGust_lastHr);
    function setWindSpdDial( oneHourSpeed ) {
        if ( oneHourSpeed > appData.windSpdDial.defaultMax ) {
            appData.windSpdDial.currentMax = onHourSpeed;
        } else {
            appData.windSpdDial.currentMax = appData.windSpdDial.defaultMax;
        }
    }
    setWindSpdDial( lastHourHigh );
    
    jQuery('.windometer-tickmark-recentHi').css('transform', `rotate(\${windSpdToAngle( lastHourHigh, appData.windSpdDial.currentMax )}deg)`);
    jQuery('.windometer-legend-hi').html ( appData.windSpdDial.currentMax );

    // More wind records
    jQuery('.windDir-1hrAvg').html( data.today.wind.windDir_1hrAvg );
    jQuery('.windSpd-1hrAvg').html( data.today.wind.windSpd_1hrAvg );
    jQuery('.wind-max').html( data.today.wind.max );
    jQuery('.wind-min').html( data.today.wind.min);
    jQuery('.wind-max-time').html( data.today.wind.maxtime );
    jQuery('.wind-min-time').html( data.today.wind.maxtime );

    // outTemp records
    jQuery('.outTemp-max').html( data.today.outTemp.max );
    jQuery('.outTemp-min').html( data.today.outTemp.min );
    jQuery('.outTemp-max-time').html( data.today.outTemp.maxtime );
    jQuery('.outTemp-min-time').html( data.today.outTemp.mintime );

    // dewpoint records
    jQuery('.dewpoint-max').html( data.today.dewpoint.max );
    jQuery('.dewpoint-min').html( data.today.dewpoint.min );
    jQuery('.dewpoint-max-time').html( data.today.dewpoint.maxtime );
    jQuery('.dewpoint-min-time').html( data.today.dewpoint.mintime );

    // Barometer records
    jQuery('.barometer-trend').html( data.today.barometer.trend );
    jQuery('.barometer-max').html( data.today.barometer.max );
    jQuery('.barometer-min').html( data.today.barometer.min );
    jQuery('.barometer-max-time').html( data.today.barometer.maxtime );
    jQuery('.barometer-min-time').html( data.today.barometer.mintime );

    // Rain records
    jQuery('.rainrate-max').html( parseFloat(data.today.rain.maxRate).toFixed(2) + '"/hr' );
    jQuery('.yesterday-rain').html( parseFloat(data.today.rain.sum.yesterday).toFixed(2) + '"' );
    jQuery('.week-rain').html( parseFloat(data.today.rain.sum.week).toFixed(2) + '"' );
    jQuery('.month-rain').html( parseFloat(data.today.rain.sum.month).toFixed(2) + '"' );
    jQuery('.year-rain').html( parseFloat(data.today.rain.sum.year).toFixed(2) + '"' );

    // Almanac data
    const daylightRaw = parseInt(data.almanac.sun.daylight);
    const daylight = {
        hrs: parseInt( daylightRaw / 3600 ),
        mins: parseInt( daylightRaw / 3600 % 1 * 60 ),
    }
    jQuery('.daylight-time').html( `\${daylight.hrs}hrs \${daylight.mins}mins`);
    jQuery('.sunrise-time').html( data.almanac.sun.rise_formatted.split(' ')[0] );
    jQuery('.sunset-time').html( data.almanac.sun.set_formatted.split(' ')[0] );
    jQuery('.moonrise-time').html( data.almanac.moon.rise_formatted );
    jQuery('.moonset-time').html( data.almanac.moon.set_formatted );
    // Expand Full/New moon label
    if ( data.almanac.moon.phase == 'New' || data.almanac.moon.phase == 'Full' ) {
        jQuery('.moon-phase').html( `\${data.almanac.moon.phase} Moon`);
    } else {
        jQuery('.moon-phase').html( data.almanac.moon.phase );
    }
    // Draw sun and moon widget
    drawAlmanac( data );
}

function processForecast( data ) {
    function currentWx () {
        const icon = (data.current[0].response[0].periods[0].icon).split('.');
        jQuery('.current-wx-icon').html(`<img src="./icons/\${icon[0]}@2x.png">`);
        jQuery('.current-wx-text').html( data.current[0].response[0].periods[0].weatherPrimary );
    }
    function weatherAlerts () {
        const response = data.alerts[0].response;
        const wxAlerts = [];

        if ( data.alerts[0].success && data.alerts[0].error === null ) {
             for ( let i = 0; i < response.length; i++ ) {
                 const tdB = localizeDate(response[i].timestamps.beginsISO);
                 const tdE = localizeDate(response[i].timestamps.expiresISO);
                 const alertObj = {
                     name: response[i].details.name,
                     color: response[i].details.color,
                     begins: `\${tdB.a} \${tdB.t} \${tdB.p}`,
                     ends: `\${tdE.a} \${tdE.t} \${tdE.p}`,
                 }
                 // alertObj.name = response[i].details.name;
                 // alertObj.color = response[i].details.color;
                 // alertObj.begins = `\${tdB.a} \${tdB.t} \${tdB.p}`;
                 // alertObj.ends = `\${tdE.a} \${tdE.t} \${tdE.p}`;
                 wxAlerts.push(alertObj);
             }
        }
        jQuery('.weather-alerts').html(wxAlerts.map(function (a) {
            return `<div class="wx-alert" style="color:\#\${a.color};">\${a.name} - \${a.begins} until \${a.ends}</div>`
        }).join(''));
    }
    function forecast () {
        const response = data.daynight[0].response[0];

        // Loop through each day-night forecast period and build forecast section HTML
        for (let i = 0; i < response.periods.length; i++) {

            if (response.periods[i].isDay) {
                if (i === 0) {
                    jQuery(`.forecast-p\${i}-date`).html('Today');
                } else {
                    const td = localizeDate( response.periods[i].dateTimeISO );
                    jQuery(`.forecast-p\${i}-date`).html( td.A );
                }
                const temp =  parseFloat( response.periods[i].maxTempF ).toFixed(0);
                jQuery(`.forecast-p\${i}-hilo-txt`).html( 'High: ' );
                jQuery(`.forecast-p\${i}-hilo-temp`).html( `${temp} &deg;` );
                jQuery(`.forecast-p\${i}-hilo-temp`).css( 'color', colorizeTemp( temp ) );

            } else {
                if (i === 0 || i === 1) {
                    jQuery(`.forecast-p\${i}-date`).html('Tonight');
                } else {
                    const td = localizeDate( response.periods[i].dateTimeISO );
                    jQuery(`.forecast-p\${i}-date`).html( `\${td.a} Night` );
                }
                const temp = parseFloat(response.periods[i].minTempF).toFixed(0);
                jQuery(`.forecast-p\${i}-hilo-txt`).html( 'Low: ' );
                jQuery(`.forecast-p\${i}-hilo-temp`).html( `${temp} &deg;` );
                jQuery(`.forecast-p\${i}-hilo-temp`).css( 'color', colorizeTemp( temp ) );
            }

            if (response.periods[i].windSpeedMinMPH === response.periods[i].windSpeedMaxMPH ){
                jQuery(`.forecast-p\${i}-windSpd`).html(response.periods[i].windSpeedMPH + '');
            } else {
                jQuery(`.forecast-p\${i}-windSpd`).html(`\${response.periods[i].windSpeedMinMPH} - \${response.periods[i].windSpeedMaxMPH}`);
            }

            jQuery(`.forecast-p\${i}-windDir`).html(response.periods[i].windDir);
            jQuery(`.forecast-p\${i}-icon`).html(`<img src="./icons/\${response.periods[i].icon}" align="right">`);
            jQuery(`.forecast-p\${i}-wxPriCode`).html( response.periods[i].weatherPrimary );
            jQuery(`.forecast-p\${i}-pop`).html(response.periods[i].pop + '%');
            jQuery(`.forecast-p\${i}-precip`).html(response.periods[i].precipIN + '"');
        }
    }

    function metarObservations () {

        function colorizeTime ( timeUpdated ) {
            const timeDiff = (Date.now()/1000) - timeUpdated;
            if ( timeDiff < 1200 ) {
                // Fresh data, less than 20 minutes old
                jQuery('.metar-updated').css( 'color', 'rgb(90, 170, 90)' );
            } else if ( timeDiff > 1200 && timeDiff < 2400 ) {
                // Semistale data - between 20 and 40 minutes old
                jQuery('.metar-updated').css( 'color', 'rgb(244, 198, 113)' );
            } else if ( timeDiff > 2400 && timeDiff < 3600 ) {
                // Stale data - between 40 and 60 minutes old
                jQuery('.metar-updated').css( 'color', 'rgb(220, 120, 120)' );
            } else {
                // Old data - older than an hour
                jQuery('.metar-updated').css( 'color', 'rgb(160, 90, 90)' );
            }
        }

        function colorizeRules ( rule ) {
            if ( rule === 'MVFR' ) {
                jQuery('.metar-rules').css( 'color', 'rgb(102, 102, 255)' );
            } else if ( rule === 'IFR' ) {
                jQuery('.metar-rules').css( 'color', 'red' );
            } else if ( rule === 'LIFR' ) {
                jQuery('.metar-rules').css( 'color', 'rgb(204, 0, 204)' );
            } else if ( rule === 'VFR' ) {
                jQuery('.metar-rules').css( 'color', 'rgba(0,0,0,0)' );
            }
        }

        function cloudLayers ( raw ) {
            const rawSplit = raw.split(' ');
            const layers = [];
            // Build layer array with layer objects
            for ( let j = 0; j < rawSplit.length; j++ ) {
                if ( rawSplit[j].slice(0,3) === 'FEW' ){
                    layers.push({'coverage': 'Few at ','height': rawSplit[j].slice(3)*100});
                } else if ( rawSplit[j].slice(0,3) === 'SCT' ){
                    layers.push({'coverage': 'Scattered at ','height': rawSplit[j].slice(3)*100});
                } else if ( rawSplit[j].slice(0,3) === 'BKN' ){
                    layers.push({'coverage': 'Broken at ','height': rawSplit[j].slice(3)*100});
                } else if ( rawSplit[j].slice(0,3) === 'OVC' ){
                    layers.push({'coverage': 'Overcast at ','height': rawSplit[j].slice(3)*100});
                }
            }
            layers.sort(( a,b )=> b.height - a.height );
            jQuery('.metar-cloud-layer').html(layers.map((layer) => `<div>\${layer.coverage}\${layer.height}</div>`).join(''));
        }

        function processMetar (index) {
            const response = data.observations[0].response[index];
            const td = localizeDate(response.ob.dateTimeISO);

            jQuery('.metar-location').html(response.id);
            jQuery('.metar-updated').html(`\${td.t} \${td.p}`);
            colorizeTime(response.ob.timestamp);
            jQuery('.metar-weather').html(response.ob.weatherShort);
            jQuery('.metar-oat').html(`\${response.ob.tempF}&deg;F`);
            jQuery('.metar-vis').html(`\${response.ob.visibilityMI} sm`);
            jQuery('.metar-rules').html(response.ob.flightRule);
            colorizeRules(response.ob.flightRule);
            jQuery('.metar-wind-direction').html(response.ob.windDir);
            jQuery('.metar-wind-direction-deg').html(response.ob.windDirDEG);
            jQuery('.metar-wind-speed-kts').html(`\${response.ob.windSpeedKTS} kts`);
            jQuery('.metar-wind-speed-mph').html(response.ob.windSpeedMPH);
            response.ob.windGustKTS ? jQuery('.metar-wind-gust-kts').html(` G\${response.ob.windGustKTS}`) : '';
            response.ob.windGustMPH ? jQuery('.metar-wind-gust-mph').html(` G\${response.ob.windGustMPH}`) : '';
            cloudLayers( response.raw );
        }

        // Find and index our prefered stations 
        const prefered = ['$Extras.metar_id_1','$Extras.metar_id_2'];
        const stationIndex = [];
        for ( let i=0; i < prefered.length; i++ ) {
           stationIndex.push(data.observations[0].response.findIndex((station) => station.id === prefered[i]));
        }
        //  Process the metar using prefered station, use nearest if no prefered stations are present 
        stationIndex.length > 0 ? processMetar(stationIndex[0]) : processMetar(0); 
    }

    // Evoke the functions
    currentWx(); weatherAlerts(); forecast(); metarObservations();
}

//////////////////////////
// Canvas Graphics 
//////////////////////////

// Wind Compass Rose
function drawCompassRose(){
    const canvasRose = document.getElementById('rose');
    const rose = canvasRose.getContext('2d');

    const roseObj = {
        cx: canvasRose.height/2,
        cy: canvasRose.width/2,
        r: 70,
        color1: 'rgb(75,57,28)',
        divisions: 16,
        major: {
            inner: 0,
            outer: 55,
            color: 'rgb(255, 215, 0)'
        },
        middle: {
            inner: 0,
            outer: 50,
            color: 'grey'
        },
        minor: {
            inner: 0,
            outer: 40,
            color: 'grey'
        }
    }

    function Point ( angle , radius ) {
        // build the Point object
        this.degrees = ( angle );
        this.radians = ( angle + 90 ) * Math.PI / 180;
        this.radius = radius === undefined ? roseObj.r : radius;
        this.x = roseObj.cx + ( this.radius * Math.cos( this.radians ) );
        this.y = roseObj.cy + ( this.radius * Math.sin( this.radians ) );
    }

    function drawRoseTicks() {
        rose.beginPath();
        for (let i = 0; i < 36; i++ ){
            const p1 = new Point (10*i , roseObj.r - 2);
            const p2 = new Point (10*i , roseObj.r + 2);
            rose.moveTo(p1.x,p1.y);
            rose.lineTo(p2.x,p2.y);
        }
        rose.lineWidth = 2;
        rose.strokeStyle = 'grey';
        rose.stroke();
    }

    function drawPeddles() {
        rose.beginPath();
        for ( let i = 0; i < roseObj.divisions; i++ ){
            if ( i%4 == 0 ){
                const p1 = new Point (360 / roseObj.divisions * i , roseObj.major.inner );
                const p2 = new Point (360 / roseObj.divisions * i , roseObj.major.outer );
                rose.moveTo(p1.x, p1.y);
                rose.lineTo(p2.x, p2.y);
                rose.strokeStyle = roseObj.major.color;
                rose.lineWidth = 2;
            } else if ( i%4 == 1 || i%4 == 3) {
                const p1 = new Point (360 / roseObj.divisions * i , roseObj.minor.inner );
                const p2 = new Point (360 / roseObj.divisions * i , roseObj.minor.outer );
                rose.moveTo(p1.x, p1.y);
                rose.lineTo(p2.x, p2.y);
                rose.lineWidth = 2;
                rose.strokeStyle = roseObj.minor.color;
            } else if ( i%4 == 2 ) {
                const p1 = new Point (360 / roseObj.divisions * i , roseObj.middle.inner );
                const p2 = new Point (360 / roseObj.divisions * i , roseObj.middle.outer );
                rose.moveTo(p1.x, p1.y);
                rose.lineTo(p2.x, p2.y);
                rose.lineWidth = 2;
                rose.strokeStyle = roseObj.middle.color;
            }
        }
        rose.strokeStyle = 'grey';
        rose.stroke();
    }

    function drawDegreeBox () {
        rose.beginPath();
        rose.arc(roseObj.cx, roseObj.cy, 22, 0, 2*Math.PI);
        rose.fillStyle = 'rgb(40,40,40)';
        rose.fill();

        rose.beginPath();
        rose.arc(roseObj.cx, roseObj.cy, 22, 0, 2*Math.PI);
        rose.lineWidth = 2;
        rose.strokeStyle = 'rgb(150, 150, 150)';
        rose.stroke();

        // Enable this when re-configuring this for live data
        // rose.font = '20px lucida';
        // rose.textAlign = 'center';
        // rose.textBaseline = 'middle';
        // rose.fillStyle = 'white';
        // rose.fillText( windDir, roseObj.cx, roseObj.cy );

    }
    drawRoseTicks();
    drawPeddles();
    drawDegreeBox();
}
function drawCompassArrow(){
    const canvasArrow = document.getElementById('rose-arrow');
    const arrow = canvasArrow.getContext('2d');

    const arrowObj = {
        cx: canvasArrow.height/2,
        cy: canvasArrow.width/2,
        r: 70,
    }

    arrow.beginPath();
    arrow.moveTo(arrowObj.cx,arrowObj.cy-65);
    arrow.lineTo(arrowObj.cx,arrowObj.cy-75);
    arrow.lineWidth = 3;
    arrow.strokeStyle = 'red';
    arrow.stroke();
}

// Sun and moon canvas
function drawAlmanac ( data ) {
    const canvasSunPath = document.querySelector('#arcs');
    const ctx = canvasSunPath.getContext('2d');

    // The circular path which the sun, moon, and markings travel upon
    // changing radius here will scale entire drawing
    sunPath = {
        cx: canvasSunPath.width / 2,
        cy: canvasSunPath.height / 2,
        radius: 60,
        strA: 0,
        endA: Math.PI * 2
    };
    ctx.clearRect( 0 , 0, canvasSunPath.width , canvasSunPath.height );

    drawSunPath();
    drawTickMarks();
    //drawSunLight();
    drawSun();
    drawMoon();
    drawMoonPhase();

    // Point returns an object containing information about a point on the canvass
    // required paramter 'time_angle' can be a timestamp or an angle. timestamps are expected to be much much bigger than an angle
    // optional 'radius' parameter defaults to a point along the sunPath.radius circle 
    function Point ( time_angle , radius ) {

        if ( time_angle > 3600 ){
            angle = timeToAngle( time_angle );
        } else {
            angle = time_angle;
        }

        // return an angle from the percent of time passed in the midnight to midnight 24hr time period
        function timeToAngle (time) {
            //const dayStart = new Date().setHours(0,0,0,0) / 1000;
            //const dayEnd = new Date().setHours(23,59,59,999) / 1000;
            const dayStart = data.almanac.sun.antitransit.previous;
            const dayEnd = data.almanac.sun.antitransit.next;
            return ( ( time - dayStart ) / ( dayEnd - dayStart ) * 360 ) ;
        } 

        // build the Point object
        this.degrees = ( angle );
        this.radians = ( angle + 90 ) * Math.PI / 180;
        this.radius = radius === undefined ? sunPath.radius : radius;
        this.x = sunPath.cx + ( this.radius * Math.cos( this.radians ) );
        this.y = sunPath.cy + ( this.radius * Math.sin( this.radians ) );
    }

    function drawSunPath () {
        ctx.beginPath();
        ctx.arc( sunPath.cx, sunPath.cy, sunPath.radius, sunPath.strA, sunPath.endA );
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgb(20, 20, 20)';
        ctx.stroke();
    }

    function drawTickMarks () {
        const innerRadius = 2;
         const outerRadius = 9;
         const riseTick = {
             innerPoint: new Point( parseInt( data.almanac.sun.rise ), sunPath.radius + innerRadius ),
             outerPoint: new Point( parseInt( data.almanac.sun.rise ), sunPath.radius + outerRadius )
         };
         const setTick = {
             innerPoint: new Point( parseInt( data.almanac.sun.set ), sunPath.radius + innerRadius ),
             outerPoint: new Point( parseInt( data.almanac.sun.set ), sunPath.radius + outerRadius )
         };
         const noonTick = {
             innerPoint: new Point( parseInt( data.almanac.sun.transit ), sunPath.radius + innerRadius ),
             outerPoint: new Point( parseInt( data.almanac.sun.transit ), sunPath.radius + outerRadius )
         };
         ctx.beginPath();
         ctx.arc( sunPath.cx, sunPath.cy, sunPath.radius + innerRadius, riseTick.innerPoint.radians, setTick.innerPoint.radians );
         ctx.lineWidth = 2;
         ctx.strokeStyle = "rgb(255, 215, 0)";
         ctx.stroke();

         ctx.beginPath();
         ctx.moveTo( riseTick.innerPoint.x, riseTick.innerPoint.y );
         ctx.lineTo( riseTick.outerPoint.x, riseTick.outerPoint.y );
         ctx.lineWidth = 1;
         ctx.stroke();

        // const tick = {
        //     color: "rgb(128, 128, 128)",
        //     width: 3,
        //     radius: {
        //         inner: 1,
        //         outer: 8
        //     },
        //     times: [
        //         parseInt( data.almanac.sun.rise ),
        //         parseInt( data.almanac.sun.set ),
        //         parseInt( data.almanac.sun.transit )
        //     ]
        // }

        // ctx.beginPath();
        // for ( i = 0; i < tick.times.length; i++ ) {
        //     const point1 = new Point ( tick.times[i] , sunPath.radius + tick.radius.outer );
        //     const point2 = new Point ( tick.times[i] , sunPath.radius + tick.radius.inner );
        //     ctx.moveTo( point1.x, point1.y );
        //     ctx.lineTo( point2.x, point2.y );
        // }
        // ctx.lineWidth = tick.width;
        // ctx.strokeStyle = tick.color;
        // ctx.stroke();
    }

    function drawSunLight() {
        // consider moving this into tick marks or visaversa using end markers 
        const sunrise = new Point( parseInt( data.almanac.sun.rise ) );
        const sunset = new Point( parseInt( data.almanac.sun.set ) );

        const gradient = ctx.createRadialGradient( sunPath.cx , sunPath.cy , 0 , sunPath.cx, sunPath.cy , sunPath.radius + 1 );
        gradient.addColorStop(0.85, 'rgb(13, 13, 13');
        gradient.addColorStop(1, 'rgb(102, 87, 0)');

        // Sunlight slice
        ctx.beginPath();
        ctx.moveTo( sunPath.cx , sunPath.cy ); // Center of circle
        ctx.arc( sunPath.cx , sunPath.cy , sunPath.radius , sunrise.radians , sunset.radians );
        ctx.fillStyle = gradient;
        ctx.fill();
    }

    function drawSun() {
        const point = new Point( parseInt( data.timestamp ) );

        const sun = {
            x: point.x,
            y: point.y,
            sunRadius: 7,
            startAngle: 0, 
            endAngle: 2*Math.PI,
            color: "yellow"
        }
        ctx.beginPath();
        ctx.arc( sun.x, sun.y, sun.sunRadius, sun.startAngle, sun.endAngle );
        ctx.fillStyle = sun.color;
        ctx.fill();
    }

    function drawMoon() {
        const lunarDay = {
            now: parseInt( data.timestamp ),
            antitransit: {
                previous: parseInt( data.almanac.moon.antitransit.previous ),
                next: parseInt( data.almanac.moon.antitransit.next )
            }
        }
        const angle = ( ( lunarDay.now - lunarDay.antitransit.previous ) / ( lunarDay.antitransit.next - lunarDay.antitransit.previous ) ) * 360;
        const point = new Point ( angle );
        const moon = {
            x: point.x,
            y: point.y,
            moonRadius: 5,
            startAngle: 0,
            endAngle: 2*Math.PI,
            color: "white"
        }

        ctx.beginPath();
        ctx.arc( moon.x , moon.y , moon.moonRadius , moon.startAngle , moon.endAngle );
        ctx.fillStyle = moon.color;
        ctx.fill();
    }

    function drawMoonPhase() {
        const percentfull = parseInt( data.almanac.moon.percentfull );
        const phaseTimes = {
            timestamp: parseInt( data.timestamp ),
            timelimit: 864000,
            newmoon: {
                previous: parseInt( data.almanac.moon.new.previous ),
                next: parseInt ( data.almanac.moon.new.next )
            },
            fullmoon: {
                previous: parseInt( data.almanac.moon.full.previous ),
                next: parseInt( data.almanac.moon.full.next )
            }
        }
        const moon = {
            x: sunPath.cx,
            y: sunPath.cy+20,
            r: 20,
            lightColor: "rgb(139, 138, 143)",
            darkColor: "rgb(0, 0, 0)",
        };

        // determine which quarter needs to be drawn
        if ( percentfull == 0 ) {

        } else if ( percentfull < 50 && phaseTimes.timestamp - phaseTimes.newmoon.previous < phaseTimes.timelimit ) {
            drawNewToFirst(percentfull);

        } else if ( percentfull > 50 && phaseTimes.fullmoon.next - phaseTimes.timestamp < phaseTimes.timelimit ) { 
            drawFirstToFull(percentfull);

        } else if ( percentfull > 50 && phaseTimes.timestamp - phaseTimes.fullmoon.previous < phaseTimes.timelimit ) { 
            drawFullToLast(percentfull);

        } else if ( percentfull < 50 && phaseTimes.newmoon.next - phaseTimes.timestamp < phaseTimes.timelimit ) { 
            drawLastToNew(percentfull);

        } else {
            console.log("Error: Moon phase not drawn");
        }

        // ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle)
        function drawNewToFirst(percent) {
            const radiusMod = (100-(percent*2))/100;
            // Draw light on right side
            ctx.beginPath();
            ctx.ellipse (moon.x , moon.y , moon.r , moon.r , 0 , 3*Math.PI/2 , Math.PI/2 );
            ctx.fillStyle = moon.lightColor;
            ctx.fill();
            // Draw waxing light by un-shadowing it
            ctx.beginPath();
            ctx.ellipse (moon.x , moon.y , moon.r * radiusMod , moon.r , 0 , 3*Math.PI/2 , Math.PI/2 );
            ctx.fillStyle = moon.darkColor;
            ctx.fill();
        }
        function drawFirstToFull(percent) {
            const radiusMod = 2*(percent-50)/100;
            // Draw light on right side
            ctx.beginPath();
            ctx.ellipse (moon.x , moon.y , moon.r , moon.r , 0 , 3*Math.PI/2 , Math.PI/2 );
            ctx.fillStyle = moon.lightColor;
            ctx.fill();
            // Draw waxing light on left side
            ctx.beginPath();
            ctx.ellipse (moon.x , moon.y , moon.r * radiusMod , moon.r , 0 , Math.PI/2, 3*Math.PI/2 ) ;
            ctx.fillStyle = moon.lightColor;
            ctx.fill();
        }
        function drawFullToLast(percent) {
            const radiusMod = 2*(percent-50)/100;
            // Draw light on left side
            ctx.beginPath();
            ctx.ellipse (moon.x , moon.y , moon.r , moon.r , 0 , Math.PI/2 , 3*Math.PI/2 );
            ctx.fillStyle = moon.lightColor;
            ctx.fill();
            // Draw waning light on right side
            ctx.beginPath();
            ctx.ellipse (moon.x , moon.y , moon.r * radiusMod , moon.r , 0 , 3*Math.PI/2 , Math.PI/2 );
            ctx.fillStyle = moon.lightColor;
            ctx.fill();
        }
        function drawLastToNew(percent){
            const radiusMod = (100-(percent*2))/100;
            // Draw light on left side
            ctx.beginPath();
            ctx.ellipse (moon.x , moon.y , moon.r , moon.r , 0 , Math.PI/2 , 3*Math.PI/2 );
            ctx.fillStyle = moon.lightColor;
            ctx.fill();
            // Draw waxing light by shadowing light
            ctx.beginPath();
            ctx.ellipse (moon.x , moon.y , moon.r * radiusMod , moon.r , 0 , Math.PI/2 , 3*Math.PI/2 );
            ctx.fillStyle = moon.darkColor;
            ctx.fill();
        }
    }
}
